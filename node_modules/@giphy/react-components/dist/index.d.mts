import { IGif, IUser, GifID, IChannel } from '@giphy/js-types';
import React, { SyntheticEvent, ElementType, PureComponent, GetDerivedStateFromProps, ReactNode, ComponentProps, CSSProperties } from 'react';
import { GifsResult, NonPaginatedGifsResult, SearchOptions } from '@giphy/js-fetch-api';
import { debounce } from 'throttle-debounce';
import { PingbackAttributes } from '@giphy/js-analytics';

type Props$9 = {
    gif: IGif;
    className?: string;
    onClick?: (gif: IGif) => void;
};
declare const Attribution: {
    ({ gif, className, onClick }: Props$9): React.JSX.Element | null;
    className: string;
};

type GifOverlayProps = {
    gif: IGif;
    isHovered: boolean;
    onClick?: (gif: IGif) => void;
    width?: number;
    height?: number;
};

type Props$8 = {
    onClick?: (gif: IGif) => void;
};
declare const AttributionOverlay: ({ gif, isHovered, onClick }: GifOverlayProps & Props$8) => React.JSX.Element | null;

type Props$7 = {
    className?: string;
    size?: number;
    fill?: string;
};
declare const VerifiedBadge: {
    ({ className, size, fill }: Props$7): React.JSX.Element;
    className: string;
    checkMarkClassName: string;
};

type EventProps = {
    onGifVisible?: (gif: IGif, e?: SyntheticEvent<HTMLElement, Event>) => void;
    onGifSeen?: (gif: IGif, boundingClientRect: ClientRect | DOMRect) => void;
    onGifClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
    onGifRightClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
    onGifKeyPress?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
};
type GifProps = {
    gif: IGif;
    /**
     * The width of the grid in pixels. This size will also determine the renditions of the grid items.
     */
    width: number;
    /**
     * A percentage value for the container to scale into. If the container scales up to a large size
     * and there is a small `width` property, the resolution of the grid items may be poor
     */
    percentWidth?: string;
    /**
     * Usually you don't need to define a height, as it can be calculated from the width provided in the gif data.
     * Two use cases would be using your own aspect ratio, and when you need to animate the height.
     */
    height?: number;
    percentHeight?: string;
    backgroundColor?: string;
    className?: string;
    user?: Partial<IUser>;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    borderRadius?: number;
    tabIndex?: number;
    style?: any;
    lazyLoad?: boolean;
};
type Props$6 = GifProps & EventProps;
declare const Gif: {
    ({ gif, gif: { bottle_data: bottleData }, width, percentWidth, percentHeight, height: forcedHeight, onGifRightClick, className, onGifClick, onGifKeyPress, onGifSeen, onGifVisible, user, backgroundColor, overlay, hideAttribution, noLink, borderRadius, style, tabIndex, lazyLoad, }: Props$6): React.JSX.Element | null;
    className: string;
    imgClassName: string;
    imgLoadedClassName: string;
};

type Props$5 = {
    className?: string;
    user: Partial<IUser>;
    gifHeight: number;
    gifWidth?: number;
    gutter: number;
    fetchGifs: (offset: number) => Promise<GifsResult>;
    onGifsFetched?: (gifs: IGif[]) => void;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    noResultsMessage?: string | JSX.Element;
    initialGifs?: IGif[];
    backgroundColor?: string;
    borderRadius?: number;
    tabIndex?: number;
    loaderConfig?: IntersectionObserverInit;
} & EventProps;
type State$1 = {
    isFetching: boolean;
    gifs: IGif[];
    isLoaderVisible: boolean;
    isDoneFetching: boolean;
};
declare class Carousel extends PureComponent<Props$5, State$1> {
    static className: string;
    static readonly defaultProps: Readonly<{
        gutter: 6;
        user: {};
        initialGifs: never[];
    }>;
    readonly state: {
        gifs: IGif[];
        isFetching: false;
        isLoaderVisible: false;
        isDoneFetching: false;
    };
    el?: HTMLElement;
    unmounted: boolean;
    paginator: () => Promise<IGif[]>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    onLoaderVisible: (isVisible: boolean) => void;
    onFetch: debounce<() => Promise<void>>;
    render(): React.JSX.Element;
}

type EmojiVariationsListProps = {
    backgroundColor?: string;
    dividerColor?: string;
    fetchVariations: (gifId: GifID) => Promise<NonPaginatedGifsResult>;
    gif: IGif;
    gifHeight: number;
    GifProps?: Partial<React.ComponentProps<typeof Gif>>;
    gifWidth?: number;
    gutter?: number;
    hideAttribution?: boolean;
    loader?: ElementType;
    noLink?: boolean;
    onVariationsFetched?: (gifs: IGif[]) => void;
    overlay?: ElementType<GifOverlayProps>;
    tabIndex?: number;
    user?: Partial<IUser>;
} & EventProps & React.ComponentProps<'div'>;
declare function EmojiVariationsList(props: EmojiVariationsListProps): React.JSX.Element;
declare namespace EmojiVariationsList {
    var className: string;
    var dividerClassName: string;
    var loaderClassName: string;
    var variationsViewportClassName: string;
    var variationsContainerClassName: string;
}

type Props$4 = {
    className?: string;
    percentWidth?: string;
    width: number;
    user: Partial<IUser>;
    columns: number;
    gutter: number;
    layoutType?: 'GRID' | 'MIXED';
    fetchGifs: (offset: number) => Promise<GifsResult>;
    onGifsFetched?: (gifs: IGif[]) => void;
    onGifsFetchError?: (e: Error) => void;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    noResultsMessage?: string | JSX.Element;
    initialGifs?: IGif[];
    externalGifs?: IGif[];
    columnOffsets?: number[];
    backgroundColor?: string;
    borderRadius?: number;
    tabIndex?: number;
    loaderConfig?: IntersectionObserverInit;
    loader?: ElementType;
    eagerIds?: IGif['id'][];
} & EventProps;
type State = {
    isFetching: boolean;
    isError: boolean;
    gifs: IGif[];
    isLoaderVisible: boolean;
    isDoneFetching: boolean;
};
declare class Grid extends PureComponent<Props$4, State> {
    static className: string;
    static loaderClassName: string;
    static fetchDebounce: number;
    static readonly defaultProps: Readonly<{
        gutter: 6;
        user: {};
        initialGifs: never[];
    }>;
    readonly state: {
        gifs: IGif[];
        isFetching: false;
        isError: false;
        isLoaderVisible: false;
        isDoneFetching: false;
    };
    bricks?: any;
    el?: HTMLDivElement | null;
    unmounted: boolean;
    paginator: () => Promise<IGif[]>;
    static getDerivedStateFromProps: GetDerivedStateFromProps<Props$4, State>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    onLoaderVisible: (isVisible: boolean) => void;
    onFetch: debounce<() => Promise<void>>;
    render(): React.JSX.Element;
}

declare const Loader: ({ className }: {
    className?: string | undefined;
}) => React.JSX.Element;

type PingbackContextProps = {
    attributes: PingbackAttributes;
    children?: ReactNode;
};
declare const PingbackContext: React.Context<PingbackContextProps>;

type Props$3 = {
    className?: string;
    placeholder?: string;
    clear?: boolean;
    autoFocus?: boolean;
    searchDebounce?: number;
    initialTerm?: string;
    onEnter?: (term: string) => void;
};
declare const SearchBar: {
    ({ className, placeholder, clear, autoFocus, searchDebounce, onEnter, }: Props$3): React.JSX.Element;
    className: string;
};

type SearchContextProps = {
    setSearch: (searchTerm: string) => void;
    term: string;
    activeChannel: IChannel | undefined;
    setChannels: (channels: IChannel[]) => void;
    currentChannels: IChannel[];
    setActiveChannel: (channel: IChannel | undefined) => void;
    fetchGifs: (offset: number) => Promise<GifsResult>;
    fetchAnimatedText: (offset: number) => Promise<GifsResult>;
    fetchChannelSearch: (offset: number) => Promise<IChannel[]>;
    isFetching: boolean;
    trendingSearches: string[];
    searchKey: string;
    isFocused: boolean;
};
declare const SearchContext: React.Context<SearchContextProps>;
type Props$2 = {
    children: ReactNode;
    options?: SearchOptions;
    apiKey: string;
    initialTerm?: string;
    initialChannel?: IChannel;
    shouldDefaultToTrending?: boolean;
    shouldFetchChannels?: boolean;
    theme?: {
        darkMode?: boolean;
        searchbarHeight?: number;
        hideCancelButton?: boolean;
        mobileMediaQuery?: string;
        mobileSearchbarHeight?: number;
    };
};
declare const SearchContextManager: ({ children, options, apiKey, initialTerm, initialChannel, shouldDefaultToTrending, shouldFetchChannels, theme, }: Props$2) => React.JSX.Element;

declare const SuggestionBar: {
    (): React.JSX.Element;
    className: string;
};

type QuartileEvent = 0.25 | 0.5 | 0.75;

type MEDIA_STATE = 'playing' | 'paused';
type IVideo = NonNullable<IGif['video']>;
type Props$1 = {
    onStateChange?: (state: MEDIA_STATE) => void;
    onTimeUpdate?: (playhead: number) => void;
    onError?: (error: number) => void;
    onCanPlay?: () => void;
    onFirstPlay?: (msTillPlay: number) => void;
    onEnded?: () => void;
    onWaiting?: (count: number) => void;
    onLoop?: (count: number) => void;
    onEndFullscreen?: () => void;
    setVideoEl?: (el: HTMLVideoElement) => void;
    onQuartile?: (quartile: QuartileEvent) => void;
    onMuted?: (isMuted: boolean) => void;
    muted?: boolean;
    ccEnabled?: boolean;
    ccLanguage?: keyof NonNullable<IVideo['captions']>;
    loop?: boolean;
    gif: IGif;
    width: number;
    percentWidth?: string;
    height?: number;
    volume?: number;
    className?: string;
    isInPlayer?: boolean;
};
declare const Video: {
    ({ muted, ccEnabled, ccLanguage, loop, onStateChange, onTimeUpdate, onCanPlay, onFirstPlay, onWaiting, onMuted, onError, onEnded, onLoop, onQuartile, onEndFullscreen, setVideoEl, gif, width, percentWidth, height: height_, volume, className, isInPlayer, }: Props$1): React.JSX.Element | null;
    className: string;
};

type Props = {
    style?: CSSProperties;
    controls?: boolean;
    hideProgressBar?: boolean;
    hideTitle?: boolean;
    hideMute?: boolean;
    hideAttribution?: boolean;
    persistentControls?: boolean;
    onUserMuted?: (muted: boolean) => void;
    overlay?: ElementType<GifOverlayProps>;
};
declare const VideoWrapper: (props: ComponentProps<typeof Video> & Props) => React.JSX.Element;

declare const PlayPauseSize = 25;
declare const PlayIcon: ({ size }: {
    size?: number | undefined;
}) => React.JSX.Element;
declare const PauseIcon: ({ size }: {
    size?: number | undefined;
}) => React.JSX.Element;

declare const VolumeSize = 25;
declare const VolumeOnIcon: ({ size, onClick }: {
    size?: number | undefined;
    onClick?: (() => void) | undefined;
}) => React.JSX.Element;
declare const VolumeOffIcon: ({ size, onClick }: {
    size?: number | undefined;
    onClick?: (() => void) | undefined;
}) => React.JSX.Element;

declare const VideoOverlay: {
    ({ gif, isHovered, hideMuteButton, width, height, className, muted: userPrefMuted, onUserMuted, }: GifOverlayProps & {
        width: number;
        height?: number | undefined;
        className?: string | undefined;
        muted?: boolean | undefined;
        hideMuteButton?: boolean | undefined;
        onUserMuted?: ((muted: boolean) => void) | undefined;
    }): React.JSX.Element;
    imgClassName: string;
};

export { Attribution, AttributionOverlay, Carousel, EmojiVariationsList, EmojiVariationsListProps, Gif, GifOverlayProps, Grid, Loader, PauseIcon, PingbackContext, PlayIcon, PlayPauseSize, SearchBar, SearchContext, SearchContextManager, SuggestionBar, VerifiedBadge, VideoWrapper as Video, VideoOverlay, VolumeOffIcon, VolumeOnIcon, VolumeSize };
